package org.example;

import java.util.Arrays;


/**
 * https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/submissions/1819728985/?envType=problem-list-v2&envId=vthevgcm
 */
public class Main {
    public static void main(String[] args) {

    }

    /**
     * Разделяет отсортированный массив на минимальное количество групп так,
     * чтобы разница между минимальным и максимальным элементами в каждой группе
     * не превышала значение `k`.
     *
     * <p><b>Алгоритм:</b>
     * 1. Сначала массив сортируется по возрастанию, чтобы элементы шли в порядке увеличения.
     * 2. Переменная `start` запоминает первый элемент текущей группы.
     * 3. Проходим по массиву:
     *    - если текущий элемент `nums[i]` отличается от `start` больше чем на `k`,
     *      значит текущая группа завершена;
     *      → увеличиваем счётчик групп `groups++`
     *      → начинаем новую группу, присваивая `start = nums[i]`.
     * 4. После окончания цикла добавляем ещё 1 к количеству групп,
     *    потому что последняя группа всегда остаётся «открытой».
     * 5. Возвращаем общее количество групп.
     *
     * <p><b>Пример:</b><br>
     * nums = [3, 6, 1, 2, 5], k = 2
     * После сортировки → [1, 2, 3, 5, 6]
     * Группы: [1, 2, 3], [5, 6] → возвращает 2
     *
     * @param nums массив целых чисел, который нужно разделить на группы
     * @param k максимальная допустимая разница между элементами внутри одной группы
     * @return минимальное количество групп, удовлетворяющих условию
     */
    public int partitionArray(int[] nums, int k) {
        Arrays.sort(nums);
        int groups = 0;
        int start = nums[0];

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] - start > k) {
                groups++;
                start = nums[i];
            }
        }

        groups++;
        return groups;
    }
}